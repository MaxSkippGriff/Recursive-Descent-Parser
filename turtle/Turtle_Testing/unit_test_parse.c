
/*
    Unit Testing - Parser
    ---------------------

   This is the unit test version of the parser.

   The parser forms the first part of the recursive descent
   parser for turtle graphics, the simple drawing language.

   The parser receives instructions such as 'go forward, go
   left' etc, checks that the instructions comply with the
   turtle grammar, interprets the instructions and draws on
   the screen using SDL.

   To ensure that the program does not exit prematurely I
   have commented out all ERROR messages and disabled
   the clear function. This is to ensure that the screen
   does not clear every time an incorrect input is detected.

   A copy of the report generated by the testing harness is
   included in the file. The report is entitled
   unit_test_parse_results.txt. Alternatively, the report
   will be generated after compiling the code.

*/


#include "parse.h"


int main(int argc, char** argv)
{
   parser prog;
   polish_stack s;

   unit_tests();

   check_inputs(argc);

   initialise_stack(&s);

   check_file(&prog, &s, argv[1]);

   check_and_start(&prog, &s);

   free_stack(&s);


   return 0;
}

/*
   Checks whether the correct number of arguments have been
   entered.
*/
bool check_inputs(int argc)
{
   int clear=0;

   if(argc != CORRECT_INPUT){
      clear_the_screen(clear);
      fprintf(stderr, "Error: Too few arguments entered.\n");
      return false;
      exit(1);
   }
   return true;
}

/*
   Clears the screen when an error has occurred and the program
   needs to start again.
*/
bool clear_the_screen(int clear)
{
   clear = 0;

   /* clear = system("clear"); */

   if(clear != CLEAR){
      fprintf(stderr, "Error: failed to clear screen.\n");
      return false;
   }
   return clear;
   return true;
}

/*
   Initialises the stack.
*/
bool initialise_stack(polish_stack *s)
{
   s->tp = (stack_elem *) calloc(1, sizeof(stack_elem));

   if(s->tp == NULL){
     /* ERROR("Failed to create stack.");*/
      return false;
   }
   s->tp->prev = NULL;
   return true;
}

/*
   Initialises the program structure and checks whether
   the file will open.
*/
void check_file(parser *prog, polish_stack *s, char *f)
{
   int i;
   FILE *file;

   prog->num = 0;
   prog->current = 0;
   s->counter = 0;

   for(i = 0; i < LIMIT; i++){
      prog->prog_line[i][0] = '\0';
   }
   if(!(file = fopen(f, "r"))){
      fprintf(stderr, "Unable to open file.\n");
      exit(2);
   }
   i=0;
   while(fscanf(file, "%s", prog->prog_line[i++]) == SCAN && i < LIMIT){
      prog->num += 1;
   }
   if(prog->num == 0){
     /* ERROR("No Words Scanned"); */
   }
   fclose(file);
}

/*
   Checks if first instruction is opening bracket "{" and
   pushes onto stack.
*/
bool check_and_start(parser *p, polish_stack *s)
{
   if(!string_same(p->prog_line[p->current], "{")){
     /* ERROR("'{' is missing. Please check file."); */
      return false;
   }

   push_on_stack(s, p->prog_line[p->current]);

   p->current += 1;

   process_instruct_list(p, s);

   return true;
}

/*
   Checks whether strings are the same. Returns true if they
   are and false if they are not.
*/
bool string_same(char *str1, char *str2)
{
   if(strcmp(str1, str2) == 0){
      return true;
   }
   else{
      return false;
   }
}

/*
   Pushes a string onto the stack.
*/
bool push_on_stack(polish_stack *s, char *c)
{
   stack_elem *e;

   e = (stack_elem *) calloc(1, sizeof(stack_elem));

   if(e == NULL){
     /* ERROR("A problem occurred when pushing string onto stack. \
             Please check file."); */
      return false;
   }

   e->prev = s->tp;
   s->tp->i = *c;
   s->tp = e;

   return true;
}

/*
   Check if instruction is closing bracket "}" to pop last
   item "{" off the stack.
*/
void process_instruct_list(parser *p, polish_stack *s)
{
   if(string_same(p->prog_line[p->current], "}")){
      if(s->tp != NULL){
         if(pop_off_stack(s) == '{'){
            if(s->tp->prev == NULL){
               return;
            }
            else{
               p->current += 1;
         }
       }
     }
   }
   process_instruction(p, s);
   process_instruct_list(p, s);
}

/*
   Pops the last character off the stack.
*/
char pop_off_stack(polish_stack *s)
{
   free(s->tp);
   s->tp = s->tp->prev;

   if(s->tp == NULL){
    /* ERROR("Problem with number of variables on stack."); */
   }

   if(s->tp != NULL){
      return s->tp->i;
   }
   return '\0';
}

/*
   Goes through the list of possible grammar rules and checks
   whether the instructions comply with those rules.
*/
bool process_instruction(parser *p, polish_stack *s)
{
   int clear=0;

   if(string_same(p->prog_line[p->current], "FD")){
      p->current += 1;
      return check_FD(p);
   }
   else if(string_same(p->prog_line[p->current], "LT")){
      p->current += 1;
      return check_LT_RT(p);
   }
   else if(string_same(p->prog_line[p->current], "RT")){
      p->current += 1;
      return check_LT_RT(p);
   }
   else if(string_same(p->prog_line[p->current], "DO")){
      p->current += 1;
      return check_DO(p, s);
   }
   else if(string_same(p->prog_line[p->current], "SET")){
      p->current += 1;
      check_SET(p, s);
      return true;
   }
   else if(string_same(p->prog_line[p->current], "}")){
      return true;
   }
   else{
      clear_the_screen(clear);
    /*  ERROR("Instruction did not comply with rules of grammar. \
             Please check file."); */
      return false;
   }
}

/*
   Checks whether the forward instruction is in the correct
   format.
*/
bool check_FD(parser *p)
{
   int clear=0;

   if(check_varnum(p)){
      p->current += 1;
      return true;
   }
   if(check_var(p)){
      p->current += 1;
      return true;
   }
   clear_the_screen(clear);
 /*  ERROR("String does not contain an FD.\
         Please check file.\n"); */
   return false;
}

/*
   Checks whether string contains a number and an uppercase
   letter.
*/
bool check_varnum(parser *p)
{
   int clear=0;
   float number;
   char* string;

   string = p->prog_line[p->current];

   if(sscanf(string, "%f", &number)==1){
      return true;
   }
   if(isupper(string[0]) && strlen(string)==1){
      return 0;
   }
   clear_the_screen(clear);
 /*  ERROR("String does not contain a number or a letter.\
         Please check file.\n"); */
   return false;
}

/*
   Convert string to character type.
*/
bool check_var(parser *p)
{
   int clear=0;
   char test_letter;

   test_letter = *p->prog_line[p->current];

   if((test_letter >= A) && (test_letter <= Z)){
      return test_letter;
      return true;
   }
   clear_the_screen(clear);
 /* ERROR("String does not contain a Letter.\
          Please check file.\n"); */
   return false;
}

/*
   Checks LT and RT instructions. Since the functions for
   LT and RT detection are the same, I merged them into
   one.
*/
bool check_LT_RT(parser *p)
{
  int clear=0;

  if(check_varnum(p)){
    p->current += 1;
    return true;
  }
  if(check_var(p)){
    p->current += 1;
    return true;
  }
  clear_the_screen(clear);
/* ERROR("String does not contain a LT or RT.\
         Please check file.\n"); */
  return false;
}

/*
   Check if SET instruction is valid
*/
bool check_SET(parser *p, polish_stack *s)
{
   int clear=0;

   p->current += 1;

   if(string_same(p->prog_line[p->current], ":=")){
      p->current += 1;
      return check_polish(p, s);
      return true;
   }
   clear_the_screen(clear);
 /*  ERROR("String does not contain a ':='.\
          Please check file.\n"); */
   return false;
}

/*
   Check if the polish expressions used are valid.
*/
bool check_polish(parser *p, polish_stack *s)
{
  if(string_same(p->prog_line[p->current], ";")){
    p->current += 1;
    return 1;
  }
  if(check_op(p)){
     p->current += 1;
     return check_polish(p, s);
  }
  if(!check_varnum(p)){
     p->current += 1;
     return check_polish(p, s);
  }
  if(check_varnum(p)){
     p->current += 1;
     return check_polish(p, s);
  }
  return false;
}

/*
   Check whether operators used are valid.
*/
bool check_op(parser *p)
{
   char c;

   c = p->prog_line[p->current][0];

   if(strlen(p->prog_line[p->current])== 1){
      switch(c){
         case '+':
         case '-':
         case '*':
         case '/':
            return true;
         default:
            return false;
      }
   }
   return false;
}

/*
   Check if DO instruction is valid. This function is fairly
   long. I wasn't able to break it into smaller functions
   without it generating errors.
*/
bool check_DO(parser *p, polish_stack *s)
{
   int clear=0;

   p->current += 1;

   if(string_same(p->prog_line[p->current], "FROM")){
      p->current += 1;
      if(check_varnum(p) || check_var(p)){
         p->current += 1;
      }
      if(string_same(p->prog_line[p->current], "TO")){
         p->current += 1;
         if(check_varnum(p) || check_var(p)){
            p->current += 1;
         }
         if(string_same(p->prog_line[p->current], "{")){
            push_on_stack(s, p->prog_line[p->current]);
            p->current += 1;
            return true;
         }
         clear_the_screen(clear);
       /* ERROR("No '{'? Please check file."); */
         return false;
       }
       clear_the_screen(clear);
    /* ERROR("No 'TO'? Please check file."); */
       return false;
    }
    clear_the_screen(clear);
 /* ERROR("No 'FROM'? Please check file."); */
    return false;
}

/*
   Free all stack memory
*/
void free_stack(polish_stack *s)
{
   if(s->tp == NULL){
  /*  ERROR("Cannot free stack."); */
   }
   if(s != NULL){
      while(s->tp != NULL){
         free(s->tp);
         s->tp = s->tp->prev;
      }
   }
}


/* -----------------------------Unit Testing functions ----------------------------------*/

int unit_tests()
{

   printf("                                                                   \n");
   printf("********************************************************************\n");
   printf("\n*                       PARSER - UNIT TESTING                      *\n\n");
   printf("********************************************************************\n\n");

   sput_start_testing();


   sput_enter_suite("check_inputs(): Checking inputs.");
   sput_run_test(test_check_inputs);
   sput_leave_suite();

   sput_enter_suite("clear_the_screen(): Cleaning screen.");
   sput_run_test(test_clear_the_screen);
   sput_leave_suite();

   sput_enter_suite("initialise_stack(): Testing initialise stack function.");
   sput_run_test(test_init_stack);
   sput_leave_suite();

   sput_enter_suite("check_file(): Checking file.");
   sput_run_test(test_check_file);
   sput_leave_suite();

   sput_enter_suite("check_file(): Checking file.");
   sput_run_test(test_check_file_2);
   sput_leave_suite();

   sput_enter_suite("check_and_start(): Checking file.");
   sput_run_test(test_check_start);
   sput_leave_suite();

   sput_enter_suite("same_string(): Testing same string.");
   sput_run_test(test_same_string);
   sput_leave_suite();

   sput_enter_suite("push_on_stack(): Testing push stack function.");
   sput_run_test(test_push_stack);
   sput_leave_suite();

/*
   NB - Commented out due to segmentation fault
   sput_enter_suite("process_instruct_list(): Testing instruction list.");
   sput_run_test(test_instrctlist);
   sput_leave_suite();
*/

   sput_enter_suite("process_instruction(): Testing instructions.");
   sput_run_test(test_instruction);
   sput_leave_suite();

   sput_enter_suite("check_FD(): Testing fd function.");
   sput_run_test(test_fd);
   sput_leave_suite();

   sput_enter_suite("check_LT_RT(): Testing lt function.");
   sput_run_test(test_lt);
   sput_leave_suite();

   sput_enter_suite("check_LT_RT(): Testing rt function.");
   sput_run_test(test_rt);
   sput_leave_suite();

   sput_enter_suite("check_DO(): Testing do function.");
   sput_run_test(test_do_loop);
   sput_leave_suite();

   sput_enter_suite("check_SET(): Testing set function.");
   sput_run_test(test_set);
   sput_leave_suite();

   sput_enter_suite("check_varnum(): Testing varnum function.");
   sput_run_test(test_varnum);
   sput_leave_suite();

   sput_enter_suite("check_var(): Testing var function.");
   sput_run_test(test_var);
   sput_leave_suite();

   sput_enter_suite("check_polish(): Testing polish function.");
   sput_run_test(test_polish);
   sput_leave_suite();

   sput_enter_suite("check_op(): Testing op function.");
   sput_run_test(test_op);
   sput_leave_suite();

   sput_enter_suite("free_stack(): Testing free stack function.");
   sput_run_test(test_free_stack);
   sput_leave_suite();


   sput_finish_testing();

   return sput_get_return_value();

}

void test_check_inputs(void)
{

   int argc1 = 1;
   int argc2 = 2;
   int argc3 = 3;
   int argc4 = 4;
   int argc5 = 5;
   int argc6 = 6;

   sput_fail_unless(check_inputs(argc1)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc2)==1, "Correct number of arguments entered.");
   sput_fail_unless(check_inputs(argc3)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc4)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc5)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc6)==0, "Not enough arguments entered.");

}


void test_clear_the_screen(void)
{

   int clear_test1;
   int clear_test2;
   int clear_test3;
   int clear_test4;
   int clear_test5;

   clear_test1 = 6;
   clear_test2 = 1;
   clear_test3 = 3;
   clear_test4 = -1;
   clear_test5 = 10;

   sput_fail_unless(clear_the_screen(clear_test1)==0, "Screen is clear.");
   sput_fail_unless(clear_the_screen(clear_test2)==0, "Screen is not clear.");
   sput_fail_unless(clear_the_screen(clear_test3)==0, "Screen is not clear.");
   sput_fail_unless(clear_the_screen(clear_test4)==0, "Screen is not clear.");
   sput_fail_unless(clear_the_screen(clear_test5)==0, "Screen is not clear.");

}


void test_check_file(void)
{
   polish_stack s;
   parser *p;


   p = (parser *) malloc(sizeof(parser));

   if(p == NULL){
      ERROR("Malloc failure.");
   }

   check_file(p, &s, "testing_files/test_file1.txt");

   sput_fail_unless(p->num != 1, "Checking elements of structure.");
   sput_fail_unless(p->current != 1, "Checking elements of structure.");
   sput_fail_unless(p->num != 10, "Checking elements of structure.");
   sput_fail_unless(p->current != 10, "Checking elements of structure.");
   sput_fail_unless(p->num != 0, "Checking elements of structure.");
   sput_fail_unless(p->current == 0, "Checking elements of structure.");


   free(p);
}


void test_check_file_2(void)
{

   polish_stack s;
   parser *p;

   p = (parser *) malloc(sizeof(parser));

   if(p == NULL){
      ERROR("Malloc failure.");
   }

   check_file(p, &s, "testing_files/test_file2.txt");


   sput_fail_unless(p->num != 1, "Checking elements of structure.");
   sput_fail_unless(p->current != 1, "Checking elements of structure.");
   sput_fail_unless(p->num != 10, "Checking elements of structure.");
   sput_fail_unless(p->current != 10, "Checking elements of structure.");
   sput_fail_unless(p->num != 0, "Checking elements of structure.");
   sput_fail_unless(p->current == 0, "Checking elements of structure.");


   free(p);

}

void test_check_start(void)
{

   int i;
   FILE *file1 = NULL;
   FILE *file2 = NULL;
   FILE *file3 = NULL;
   FILE *file4 = NULL;
   FILE *file5 = NULL;
   parser p;
   polish_stack s;

   initialise_stack(&s);

   s.counter = 0;

   p.num = 0;
   p.current = 0;

   for(i = 0; i < MAX_LEN; i++){
      p.prog_line[i][0] = '\0';
   }

   file1 = fopen("testing_files/test_file1.txt", "r");

   while(fscanf(file1, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file1);

   sput_fail_unless(check_and_start(&p, &s) == 0, "Incorrect opening bracket identified.");


   file2 = fopen("testing_files/test_file2.txt", "r");

   while(fscanf(file2, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file2);

   sput_fail_unless(check_and_start(&p, &s) == 0, "Missing opening bracket identified.");


   file3 = fopen("testing_files/test_file3.txt", "r");

   while(fscanf(file3, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file3);

   sput_fail_unless(check_and_start(&p, &s) == 0, "Missing opening bracket identified.");


   file4 = fopen("testing_files/test_file4.txt", "r");

   while(fscanf(file4, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file4);

   sput_fail_unless(check_and_start(&p, &s) == 0, "Missing opening bracket identified.");


   file5 = fopen("testing_files/test_file5.txt", "r");

   while(fscanf(file5, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file5);

   sput_fail_unless(check_and_start(&p, &s) == 0, "Missing opening bracket identified.");

}


void test_same_string(void)
{

   char *str1 = "{";    char *str11 = "}";
   char *str2 = "{";    char *str12 = "}";

   char *str3 = "FROM"; char *str13 = ":=";
   char *str4 = "FROM"; char *str14 = ":=";

   char *str5 = "TO";   char *str15 = ";";
   char *str6 = "TO";   char *str16 = ";";

   char *str7 = "SET";  char *str17 = "FD";
   char *str8 = "SET";  char *str18 = "FD";

   char *str9 = "DO";   char *str19 = "LT";
   char *str10 = "DO";  char *str20 = "LT";


   sput_fail_unless(string_same(str1, str2) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str3, str4) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str5, str6) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str7, str8) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str9, str10) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str11, str12) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str13, str14) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str15, str16) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str17, str18) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str19, str20) == 1, "Same string correctly identified.");

   sput_fail_unless(string_same(str1, str11) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str2, str12) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str3, str13) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str4, str14) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str5, str15) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str6, str16) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str7, str17) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str8, str18) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str9, str19) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str10, str20) == 0, "Different string correctly identified.");

}

/*
void test_instrctlist(void)
{

   parser prog;
   polish_stack s;

   test_instrctlist_check(&prog, &s);

}


void test_instrctlist_check(parser *prog, polish_stack *s)
{
   srand(time(NULL));

   prog = (parser *) malloc(sizeof(parser));

   process_instruct_list(prog, s);

   prog->current = rand() % MAX_LEN;

   strcpy(prog->prog_line[prog->current], "}");

   process_instruct_list(prog, s);

   sput_fail_unless(prog -> prog_line[prog -> current] != 0, "Checking elements of structure.");
   sput_fail_unless(prog -> prog_line[prog -> current+1] != 0, "Checking elements of structure.");

   free(prog);

}*/



void test_instruction(void)
{

   parser *prog_location;

   polish_stack s;

   prog_location =  (parser *) malloc(sizeof(parser));

   if(prog_location == NULL){
      ERROR("Malloc failure.");
   }

   /* First test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "F 30 }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Second test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "L 4 }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed LT which is valid so should return 1.");

   /* Third test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "T 4 }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed RT which is valid so should return 1.");

   /* Fourth test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "O A FROM 1 TO 5 { FD 5 } }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Fifth test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "FROM }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Sixth test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], " }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Seventh test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "0 }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Eighth test  */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "z }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Ninth test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "m 60 }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   /* Tenth test */

   check_and_start(prog_location, &s);

   strcpy(prog_location->prog_line[prog_location->current], "s }");

   sput_fail_unless(process_instruction(prog_location, &s)== 0, "Passed FD which is valid so should return 1.");

   free(prog_location);
}

/*
   Check that function Forward() only recognises "FD"
   instruction followed by <VARNUM> as correct grammar
*/
void test_fd(void)
{
   parser prog;

   sput_fail_unless(test_fd_check(&prog, "FD", "10")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "4")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "8")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "12")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "1")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "14")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "11")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "10")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "9")==1, "Correct input passed.");
   sput_fail_unless(test_fd_check(&prog, "FD", "A")==1, "Correct input passed.");

   sput_fail_unless(test_fd_check(&prog, "FS", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "FT", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "FV", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "BU", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "ST", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "RE", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "DO", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "SET", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "DOT", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, "PT", "A")==0, "Incorrect input failed.");

}

/*
   Check that function LeftTurn() only recognises "LT"
   instruction followed by <VARNUM> as correct grammar
*/
bool test_fd_check(parser *prog, char* first, char* second)
{

  prog->current = 0;

  strcpy(prog->prog_line[prog->current], first);
  strcpy(prog->prog_line[prog->current+1], second);

  if(string_same(prog->prog_line[prog->current], "FD")){
     prog->current += 1;
     return check_FD(prog);

     return true;
  }
  return false;

}


void test_lt(void)
{
   parser prog;

   sput_fail_unless(test_lt_check(&prog, "LT", "10")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "4")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "8")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "12")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "1")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "14")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "11")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "10")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "9")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, "LT", "19")==1, "Correct input passed.");

   sput_fail_unless(test_lt_check(&prog, "FS", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "FT", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "FV", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "BU", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "ST", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "RE", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "DO", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "SET", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "DOT", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, "PT", "A")==0, "Incorrect input failed.");

}


bool test_lt_check(parser *prog, char* first, char* second)
{

  prog->current = 0;

  strcpy(prog->prog_line[prog->current], first);
  strcpy(prog->prog_line[prog->current+1], second);

  if(string_same(prog->prog_line[prog->current], "LT")){
     prog->current += 1;
     return check_LT_RT(prog);

     return true;
  }
  return false;

}

void test_rt(void)
{
   parser prog;

   sput_fail_unless(test_rt_check(&prog, "RT", "10")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "4")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "8")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "12")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "1")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "14")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "11")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "10")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "9")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "19")==1, "Correct input passed.");

   sput_fail_unless(test_rt_check(&prog, "RS", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "do")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "RW", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "RU", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "RT", "x")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "RE", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "RO", "15")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "SET", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "DOT", "35")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, "PT", "A")==0, "Incorrect input failed.");

}

bool test_rt_check(parser *prog, char* first, char* second)
{

  prog->current = 0;

  strcpy(prog->prog_line[prog->current], first);
  strcpy(prog->prog_line[prog->current+1], second);

  if(string_same(prog->prog_line[prog->current], "RT")){
     prog->current += 1;
     return check_LT_RT(prog);

     return true;
  }
  return false;

}


void test_do_loop(void)
{

   parser prog;
   polish_stack s;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");
   sput_fail_unless(test->test_count != 1, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "DOOO";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "1";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "50";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Second test */

   test->test_arr[0] = "FROM";
   test->test_arr[1] = "A";
   test->test_arr[2] = "DO";
   test->test_arr[3] = "B";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "A";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Third test */

   test->test_arr[0] = ")";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "A";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "B";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Fourth test */

   test->test_arr[0] = "} DO";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "A";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "B";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Fifth test */

   test->test_arr[0] = " ";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "1";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "8";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   free(test);

}


bool test_do_check(parser *prog, polish_stack *s, test_array *test)
{

   int i=0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(string_same(prog->prog_line[prog->current], "DO")){
      prog->current += 1;
      check_DO(prog, s);
      return true;
   }
   else{
      return false;
   }

   free(test);

}

/*
   Check that function Set() parses the
   instructions stored in e.array as correct
   grammar.
*/
void test_set(void)
{

   parser prog;
   polish_stack s;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Fourth test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Fifth test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Sixth test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Seventh test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Eighth test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Ninth test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Tenth test */

   test->test_arr[0] = "SET";
   test->test_arr[1] = "L";
   test->test_arr[2] = ":=";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_set_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   free(test);

}


bool test_set_check(parser *prog, polish_stack *s, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(string_same(prog->prog_line[prog->current], "SET")){
      prog->current += 1;
      check_SET(prog, s);
      return true;
   }
   else{
      return false;
   }

   free(test);

}

/*
   Check that function VarNum() can distinguish
   between a string containing a number and a string
   containing an uppercase letter.
*/
void test_varnum(void)
{

   parser prog;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "5";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = "10";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = "4.9";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fourth test */

   test->test_arr[0] = "3.6";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fifth test */

   test->test_arr[0] = "20";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Sixth test */

   test->test_arr[0] = "Y";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Seventh test */

   test->test_arr[0] = "Z";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Eighth test */

   test->test_arr[0] = "P";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Ninth test */

   test->test_arr[0] = "DO";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Tenth test */

   test->test_arr[0] = "SET";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   free(test);

}

bool test_varnum_check(parser *prog, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(check_varnum(prog)){
      return true;
   }
   return false;

}

void test_var(void)
{

   parser prog;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "A";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = "S";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = "K";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fourth test */

   test->test_arr[0] = "P";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fifth test */

   test->test_arr[0] = "E";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Sixth test */

   test->test_arr[0] = "a";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Seventh test */

   test->test_arr[0] = "6";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Eighth test */

   test->test_arr[0] = "f";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Ninth test */

   test->test_arr[0] = "2.3";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Tenth test */

   test->test_arr[0] = "5.5";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   free(test);

}

/*
   Check that function Var() converts a string
   containing an uppercase letter into a character
*/
bool test_var_check(parser *prog, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }
   if(check_var(prog)){
      return true;
   }
   return false;

}


void test_polish(void)
{

   parser prog;
   polish_stack s;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = ";";
   test->test_arr[1] = "/";
   test->test_arr[2] = "12";
   test->test_arr[3] = "4";

   test->test_count = 4;

   sput_fail_unless(test_polish_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = ";";
   test->test_arr[1] = "+";
   test->test_arr[2] = "6";
   test->test_arr[3] = "6";

   test->test_count = 4;

   sput_fail_unless(test_polish_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = ";";
   test->test_arr[1] = "/";
   test->test_arr[2] = "16";
   test->test_arr[3] = "8";

   test->test_count = 4;

   sput_fail_unless(test_polish_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Fourth test */

   test->test_arr[0] = ";";
   test->test_arr[1] = "/";
   test->test_arr[2] = "6";
   test->test_arr[3] = "3";

   test->test_count = 4;

   sput_fail_unless(test_polish_check(&prog, &s, test) == 1, "Correctly parsed instructions.");

   /* Fifth test */

   test->test_arr[0] = ";";
   test->test_arr[1] = "+";
   test->test_arr[2] = "20";
   test->test_arr[3] = "10";

   test->test_count = 4;

   sput_fail_unless(test_polish_check(&prog, &s, test) == 1, "Correctly parsed instructions.");


   free(test);

}


bool test_polish_check(parser *prog, polish_stack *s, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(check_polish(prog, s)){
      return true;
   }
   else{
      return false;
   }

}


void test_op(void)
{

   parser prog;


   sput_fail_unless(test_op_check(&prog, "+") == 1, "Correctly parsed instructions.");
   sput_fail_unless(test_op_check(&prog, "-") == 1, "Correctly parsed instructions.");
   sput_fail_unless(test_op_check(&prog, "*") == 1, "Correctly parsed instructions.");
   sput_fail_unless(test_op_check(&prog, "/") == 1, "Correctly parsed instructions.");

   sput_fail_unless(test_op_check(&prog, "3") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "10") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "2.5") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "3.3") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "a") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "}") == 0, "Correctly identified invalid instructions.");

}


bool test_op_check(parser *prog, char *test)
{

   prog->current = 0;

   strcpy(prog->prog_line[prog->current], test);

   if(check_op(prog)){
      return true;
   }
   else{
      return false;
   }

}

/*
   Check that the stack pointer is not NULL
*/
void test_init_stack(void)
{

   polish_stack stack, *s;

   s = &stack;

   initialise_stack(s);

   sput_fail_unless(s->tp != 0, "Stack initialisation complete.");
   assert(s != NULL);

   assert(s->tp != NULL);
   sput_fail_unless(s->tp != 0, "Stack initialisation complete.");

   sput_fail_unless(s->counter == 0, "Stack initialisation complete.");

   sput_fail_unless(initialise_stack(s) == 1, "Correctly initialised stack.");

   sput_fail_unless(s->counter == 0, "Correctly initialised stack.");
   sput_fail_unless(s->tp != 0, "Correctly initialised stack.");
   sput_fail_unless(s->tp->prev == 0, "Correctly initialised stack.");

}

/*
   Check that function Push() will push a string containing
   a character or number (first digit only) onto the stack.

   Check that function Pop() will pop the last element
   (only the first digit for numbers) off the stack.
*/
void test_push_stack(void)
{

   polish_stack stack, *s;

   s = &stack;

   initialise_stack(s);

   push_on_stack(s, "5");

   assert(s != NULL);
   assert(s->tp != NULL);

   assert(pop_off_stack(s)== '5');
   sput_fail_unless(pop_off_stack(s)== 0, "Stack initialisation complete.");
   sput_fail_unless(s->tp == 0, "5 is at the top of the stack.");
/*
   push_on_stack(s, "1");

   assert(s != NULL);
   assert(s->tp != NULL);

   assert(pop_off_stack(s)== '1');
   sput_fail_unless(pop_off_stack(s)== 0, "Stack initialisation complete.");
   sput_fail_unless(s->tp == 0, "1 is at the top of the stack.");

   push_on_stack(s, "30");

   assert(s != NULL);
   assert(s->tp != NULL);

   assert(pop_off_stack(s)== '3');
   sput_fail_unless(pop_off_stack(s) == 0, "Stack initialisation complete.");
   sput_fail_unless(s->tp == 0, "3 is at the top of the stack."); */

   free_stack(s);

}


void test_free_stack(void)
{

   polish_stack stack, *s;

   s = &stack;

   initialise_stack(s);

   free_stack(s);

   sput_fail_unless(s->tp == 0, "Stack freed.");

}
