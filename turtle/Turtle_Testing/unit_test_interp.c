
/*
    Unit Testing - Interpreter
    ---------------------------

   This is the unit test version of the interpreter.

   The interpreter forms the second part of the recursive
   descent parser for turtle graphics, the simple drawing
   language.

   The parser receives instructions such as 'go forward, go
   left' etc, checks that the instructions comply with the
   turtle grammar, interprets the instructions and draws on
   the screen using SDL.

   To ensure that the program does not exit prematurely I
   have commented out all ERROR messages and disabled
   the clear function. This is to ensure that the screen
   does not clear every time an incorrect input is detected.

   A copy of the report generated by the testing harness is
   included in the file. The report is entitled
   unit_test_interp_results.txt. Alternatively, the report
   will be generated after compiling the code.

*/


#include "interp.h"


int main(int argc, char** argv)
{
   interp prog;
   SDL_Simplewin w;
   turtle xy_coords;
   polish_stack s;

   unit_tests();

   check_inputs(argc);

   initialise_stack(&s);

   check_file(&prog, &s, argv[1], &xy_coords);

   start_SDL(&w, &xy_coords);

   check_and_start(&prog, &s, &w, &xy_coords);

   SDL_Quit();

   atexit(SDL_Quit);

   free_stack(&s);

   return 0;

}


bool check_inputs(int argc)
{
   int clear=0;

   if(argc != CORRECT_INPUT){
      clear_the_screen(clear);
      fprintf(stderr, "Error: Too few arguments entered.\n");
      return false;
      exit(1);
   }
   return true;
}


bool clear_the_screen(int clear)
{
   clear = 0;
  /* clear = system("clear"); */

   if(clear != CLEAR){
      fprintf(stderr, "Error: failed to clear screen.\n");
      return false;
   }
   return clear;
   return true;
}


bool initialise_stack(polish_stack *s)
{
   s->tp = (stack_elem *) calloc(1, sizeof(stack_elem));

   if(s->tp == NULL){
      return false;
      ERROR("Failed to create stack.");
   }
   s->tp->prev = NULL;
   return true;

}


void check_file(interp *prog, polish_stack *s, char *f,
                turtle *xy_coords)
{
   int i;
   FILE *fp;

   prog->num = 0;
   prog->current = 0;
   s->counter = 0;

   for(i = 0; i < LIMIT; i++){
      prog->prog_line[i][0] = '\0';
   }

   if(!(fp = fopen(f, "r"))){
      fprintf(stderr, "Cannot open.\n");
      exit(1);
   }
   i = 0;
   while(fscanf(fp, "%s", prog->prog_line[i++]) == SCAN && i < LIMIT){
      prog->num = prog->num + 1;
   }
   fclose(fp);

   for(i = 0; i < SIZE; i++){
      xy_coords->array[i] = 0;
      xy_coords->values[i] = 0;
   }
}

/*
   Initialise SDL window and set line colour
   check_SET initial coordinates.
*/
void start_SDL(SDL_Simplewin *w, turtle *xy_coords)
{
   Neill_SDL_Init(w);
   Neill_SDL_SetDrawColour(w, WHITE, WHITE, WHITE);

   xy_coords->next_x = START_VAL_X;
   xy_coords->next_y = START_VAL_Y;
   xy_coords->angle = 0;

   SDL_Delay(GRAPHICS_PAUSE);
}

/*
   Check if first prog_lineruction is "{" and
   push onto stack
*/
bool check_and_start(interp *p, polish_stack *s, SDL_Simplewin *w,
                     turtle *xy_coords)
{
   if(!string_same(p->prog_line[p->current], "{")){
    /*  ERROR("No Opening Bracket"); */
      return false;
   }

   push_on_stack(s, p->prog_line[p->current]);

   p->current += 1;

   process_instruct_list(p, s, w, xy_coords);

   SDL_Delay(GRAPHICS_PAUSE);

   return true;
}


bool string_same(char *str1, char *str2)
{
   if(strcmp(str1, str2) == 0){
      return true;
   }
   else{
      return false;
   }
}


bool push_on_stack(polish_stack *s, char* c)
{
   stack_elem *e;

   e = (stack_elem *) calloc(1, sizeof(stack_elem));

   if(e == NULL){
   /* ERROR("Creation of polish_stack stack_element Failed"); */
      return false;
   }
   e->prev = s->tp;
   s->tp->i = *c;
   s->tp = e;

   return true;
}


void process_instruct_list(interp *p, polish_stack *s,
                           SDL_Simplewin *w, turtle *xy_coords)
{
   if(string_same(p->prog_line[p->current], "}")){
      if(s->tp != NULL){
         if(pop_off_stack(s) == '{'){
            if(s->tp->prev == NULL){
               return;
            }
            else{
               p->current += 1;
               return;
           }
        }
     }
   }
   process_instruction(p, s, w, xy_coords);
   process_instruct_list(p, s, w, xy_coords);
}


char pop_off_stack(polish_stack *s)
{
   free(s->tp);

   s->tp = s->tp->prev;

   if(s->tp == NULL){
     /* ERROR("Problem with number of variables on stack."); */
   }

   if(s->tp != NULL){
      return s->tp->i;
   }
   return '\0';
}


bool process_instruction(interp *p, polish_stack *s, SDL_Simplewin *w,
                        turtle *xy_coords)
{
   int clear=0;

   if(string_same(p->prog_line[p->current], "FD")){
      p->current += 1;
      return check_FD(p, w, xy_coords);
      return true;
   }
   if(string_same(p->prog_line[p->current], "LT")){
      p->current += 1;
      return check_LT_RT(p, xy_coords);
      return true;
   }
   if(string_same(p->prog_line[p->current], "RT")){
      p->current += 1;
      return check_LT_RT(p, xy_coords);
      return true;
   }
   if(string_same(p->prog_line[p->current], "DO")) {
      p->current += 1;
      return check_DO(p, s, w, xy_coords);
   }
   if(string_same(p->prog_line[p->current], "SET")) {
      p->current += 1;
      return check_SET(p, s, xy_coords);
   }
   if(string_same(p->prog_line[p->current], "}")) {
      return true;
   }
   clear_the_screen(clear);
  /* ERROR("Instruction did not comply with rules of grammar. \
          Please check file."); */
   return false;
}

/*
   Check_SET previous coordinates and calculate new coordinates
   based on angle
*/
double check_FD(interp *p, SDL_Simplewin *w, turtle *xy_coords)
{
   int value;
   double num;
   char check_letter;

   if(check_varnum(p)){
      num = check_var_dec(p);
      p->current += 1;
   }
   else{
      check_letter = check_var(p);
      value = check_letter - A;
      num = xy_coords->array[value];
      p->current += 1;
   }

   xy_coords->prev_x = xy_coords->next_x;
   xy_coords->prev_y = xy_coords->next_y;
   xy_coords->next_x = xy_coords->next_x + \
                       num*cos(xy_coords->angle);
   xy_coords->next_y = xy_coords->next_y + \
                       num*sin(xy_coords->angle);

   return draw_line(w, xy_coords, num);
}


bool check_varnum(interp *p)
{
   float num;
   char* str;

   str = p->prog_line[p->current];

   if(sscanf(str, "%f", &num)==1){
      return true;
   }
   if(isupper(str[0]) && strlen(str)==1){
      return 0;
   }
  /* ERROR("No letter or number?"); */
   return false;
}


double check_var_dec(interp *p)
{
   double num;

   num = atof(p->prog_line[p->current]);

   return num;
}


bool check_var(interp *p)
{
   char letter;
   /* get_value string to character type */
   letter = *p->prog_line[p->current];

   if((letter >= A) && (letter <= Z)) {
      return letter;
      return true;
   }
   /* ERROR("Problem with letter."); */
   return false;
}

/*
   Draw line in SDL based on previous and new coordinates
*/
double draw_line(SDL_Simplewin *w, turtle *xy_coords, double num)
{
   SDL_RenderDrawLine(w->renderer, xy_coords->prev_x,
                      xy_coords->prev_y, xy_coords->next_x, \
                      xy_coords->next_y);
   Neill_SDL_UpdateScreen(w);

   Neill_SDL_Events(w);

   SDL_Delay(WAIT_TIME);

  return num;
}


double check_LT_RT(interp *p, turtle *xy_coords)
{
   double num;
   char check_letter;
   int val;

   if(check_varnum(p)){
      num = check_var_dec(p);
   }
   else{
      check_letter = check_var(p);
      val = check_letter - A;
      num = xy_coords->array[val];
   }
   /* check_SET new angle based on old angle */
   xy_coords->angle = xy_coords->angle - num * PI/TURN_DEGREES;
   p->current += 1;

   return num;
}


bool check_SET(interp *p, polish_stack *s, turtle *xy_coords)
{
   char lett;
   int val;
   double calc;

   lett = check_var(p);
   val = lett - A;

   p->current += 1;

   if(string_same(p->prog_line[p->current], ":=")){
      p->current += 1;
      calc = check_polish(p, s, xy_coords);
      xy_coords->array[val] = calc;

      return true;
   }
  /* ERROR("No :=?"); */
   return false;
}


bool check_polish(interp *p, polish_stack *s, turtle *xy_coords)
{
   double calc=0;

   if(string_same(p->prog_line[p->current], ";")){
      if(s->counter == 0){
        /* ERROR("No value?"); */
         return false;
      }

      pop_off_stack(s);
      s->counter -= 1;
      calc = xy_coords->values[s->counter];

      while(s->counter > 0){
         pop_off_stack(s);
         s->counter -= 1;
      }

      p->current += 1;
      return calc;

   }
   return Polish_check_op(p, s, xy_coords, calc);
   return true;
}


bool Polish_check_op(interp *p, polish_stack *s, turtle *xy_coords,
                       double calc)
{
   int op;
   char buffer[SIZE];

   if(check_op(p)){
      if(s->counter < STACK_CNT){
       /* ERROR("Not 2?"); */
         return false;
      }

      op = check_op(p);
      calc = do_maths(s, xy_coords, op);
      xy_coords->values[s->counter] = calc;

      sprintf(buffer, "%f", calc);
      push_on_stack(s, buffer);

      s->counter += 1;
      p->current += 1;

      return check_polish(p, s, xy_coords);

   }
   return Polish_varnum(p, s, xy_coords);
   return true;
}

/* If string contains a number, push onto stack and keep parsing */
/* If string contains a character, push onto stack and keep parsing */
bool Polish_varnum(interp *p, polish_stack *s, turtle *xy_coords)
{
   double num;

     if(!check_varnum(p)){
        push_on_stack(s, p->prog_line[p->current]);

        s->counter += 1;
        p->current += 1;

        return check_polish(p, s, xy_coords);
     }
     if(check_varnum(p)){
        num = check_var_dec(p);
        xy_coords->values[s->counter] = num;

        push_on_stack(s, p->prog_line[p->current]);

        s->counter += 1;
        p->current += 1;

        return check_polish(p, s, xy_coords);
     }
     return false;
}

bool check_op(interp *p)
{
   char c;

   c = p->prog_line[p->current][0];

   if(strlen(p->prog_line[p->current])== 1){
      switch(c){
         case '+':
         case '-':
         case '*':
         case '/':
            return true;
         default:
            return false;
      }
   }
   return false;
}

/*
   Arithmetic calculation of two operands and an operator
*/
bool do_maths(polish_stack *s, turtle *xy_coords, int op)
{
   double a, b;

   a = get_value(s, xy_coords);
   b = get_value(s, xy_coords);

   switch (op){
      case 1:
         return a + b;
      case 2:
         return a - b;
      case 3:
         return a * b;
      case 4:
         return a / b;
      default:
       /*  ERROR("Invalid operator."); */
         return false;
    }
    return false;
}

/*
   Retrieve the value saved by popping off its reference
   from the stack.
*/
double get_value(polish_stack *s, turtle *xy_coords)
{
   int val;
   double num;
   char lett[SIZE];

   lett[0] = pop_off_stack(s);
   lett[1] = '\0';

   s->counter -= 1;

   if(atoi(lett)) {
      num = xy_coords->values[s->counter];
      return num;
   }
   if((lett[0] >= A) && (lett[0] <= Z)) {
      val = lett[0] - A;
      num = xy_coords->array[val];
      return num;
  }
  return 0;
}

/*
   Check if DO program prog_lineruction is valid
*/
bool check_DO(interp *p, polish_stack *s, SDL_Simplewin *w,
             turtle *xy_coords)
{
   int row=0, value=0, clear=0, val=0;
   double a=0, b=0, min_val=0, max_val=0;
   char letter='\0', check_letter='\0';

   check_letter = check_var(p);
   val = check_letter - A;

   p->current += 1;
   if(string_same(p->prog_line[p->current], "FROM")){
      p->current = p->current + 1;
      if(check_varnum(p)){
         a = check_var_dec(p);
         min_val = a;
         xy_coords->array[val] = min_val;
      }
      else{
         letter = check_var(p);
         value = letter - A;
         min_val = xy_coords->array[value];
         xy_coords->array[val] = min_val;
      }
      p->current += 1;
      if(string_same(p->prog_line[p->current], "TO")){
         p->current = p->current + 1;
         if(check_varnum(p)){
            b = check_var_dec(p);
            max_val = b;
         }
         else{
            letter = check_var(p);
            value = letter - A;
            max_val = xy_coords->array[value];
        }
        p->current += 1;
        if(string_same(p->prog_line[p->current], "{")){
           return check_brackets(p, s, w, xy_coords,
                                 max_val, row, val);
        }
        clear_the_screen(clear);
      /*  ERROR("No '{'? Please check file."); */
        return false;
      }
      clear_the_screen(clear);
    /*  ERROR("No 'TO'? Please check file."); */
      return false;
  }
  clear_the_screen(clear);
 /* ERROR("No 'FROM'? Please check file."); */
  return false;
}


bool check_brackets(interp *p, polish_stack *s, SDL_Simplewin *w,
                   turtle *xy_coords, double max, int row, int val)
{
   push_on_stack(s, p->prog_line[p->current]);
   p->current += 1;
   row = p->current;

   while(xy_coords->array[val] <= max){
      process_instruct_list(p, s, w, xy_coords);
      if(string_same(p->prog_line[p->current], "}")){
         xy_coords->array[val] = xy_coords->array[val] + 1;
         if(xy_coords->array[val] <= max){
            p->current = row;
            push_on_stack(s, "{");
         }
      }
   }
  return true;
}

/*
   Free all stack memory
*/
void free_stack(polish_stack *s)
{
   if(s->tp == NULL){
   /*  ERROR("Cannot free stack."); */
   }
   if(s != NULL){
      while(s->tp != NULL){
         free(s->tp);
         s->tp = s->tp->prev;
    }
  }
}


/* -----------------------------Unit Testing functions ----------------------------------*/

int unit_tests()
{

   printf("                                                                   \n");
   printf("********************************************************************\n");
   printf("\n*                  INTERPRETER - UNIT TESTING                      *\n\n");
   printf("********************************************************************\n\n");

   sput_start_testing();


   sput_enter_suite("check_inputs(): Checking inputs.");
   sput_run_test(test_check_inputs);
   sput_leave_suite();

   sput_enter_suite("clear_the_screen(): Cleaning screen.");
   sput_run_test(test_clear_the_screen);
   sput_leave_suite();

   sput_enter_suite("initialise_stack(): Testing initialise stack function.");
   sput_run_test(test_init_stack);
   sput_leave_suite();

   sput_enter_suite("check_file(): Checking file.");
   sput_run_test(test_check_file);
   sput_leave_suite();

   sput_enter_suite("check_file(): Checking file.");
   sput_run_test(test_check_file_2);
   sput_leave_suite();

   sput_enter_suite("check_and_start(): Checking file.");
   sput_run_test(test_check_start);
   sput_leave_suite();

   sput_enter_suite("same_string(): Testing same string.");
   sput_run_test(test_same_string);
   sput_leave_suite();

   sput_enter_suite("push_on_stack(): Testing push stack function.");
   sput_run_test(test_push_stack);
   sput_leave_suite();

/*
   Commented out due to persistent segmentation fault.
   sput_enter_suite("process_instruct_list(): Testing instruction list.");
   sput_run_test(test_instrctlist);
   sput_leave_suite();
*/

   sput_enter_suite("process_instruction(): Testing instructions.");
   sput_run_test(test_instruction);
   sput_leave_suite();

   sput_enter_suite("check_FD(): Testing fd function.");
   sput_run_test(test_fd);
   sput_leave_suite();

   sput_enter_suite("check_LT_RT(): Testing lt function.");
   sput_run_test(test_lt);
   sput_leave_suite();

   sput_enter_suite("check_LT_RT(): Testing rt function.");
   sput_run_test(test_rt);
   sput_leave_suite();

   sput_enter_suite("check_DO(): Testing do function.");
   sput_run_test(test_do_loop);
   sput_leave_suite();

   sput_enter_suite("check_SET(): Testing set function.");
   sput_run_test(test_set);
   sput_leave_suite();

   sput_enter_suite("check_varnum(): Testing varnum function.");
   sput_run_test(test_varnum);
   sput_leave_suite();

   sput_enter_suite("check_var(): Testing var function.");
   sput_run_test(test_var);
   sput_leave_suite();

   /* Persistent segmentation fault */

   sput_enter_suite("check_polish(): Testing polish function.");
   sput_run_test(test_polish);
   sput_leave_suite();

   sput_enter_suite("check_op(): Testing op function.");
   sput_run_test(test_op);
   sput_leave_suite();

   sput_enter_suite("free_stack(): Testing free stack function.");
   sput_run_test(test_free_stack);
   sput_leave_suite();


   sput_finish_testing();

   return sput_get_return_value();

}

void test_check_inputs(void)
{

   int argc1 = 1;
   int argc2 = 2;
   int argc3 = 3;
   int argc4 = 4;
   int argc5 = 5;
   int argc6 = 6;

   sput_fail_unless(check_inputs(argc1)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc2)==1, "Correct number of arguments entered.");
   sput_fail_unless(check_inputs(argc3)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc4)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc5)==0, "Not enough arguments entered.");
   sput_fail_unless(check_inputs(argc6)==0, "Not enough arguments entered.");

}


void test_clear_the_screen(void)
{

   int clear_test1;
   int clear_test2;
   int clear_test3;
   int clear_test4;
   int clear_test5;

   clear_test1 = 5;
   clear_test2 = 2;
   clear_test3 = 3;
   clear_test4 = -1;
   clear_test5 = 10;

   sput_fail_unless(clear_the_screen(clear_test1)==0, "Screen is clear.");
   sput_fail_unless(clear_the_screen(clear_test2)==0, "Screen is not clear.");
   sput_fail_unless(clear_the_screen(clear_test3)==0, "Screen is not clear.");
   sput_fail_unless(clear_the_screen(clear_test4)==0, "Screen is not clear.");
   sput_fail_unless(clear_the_screen(clear_test5)==0, "Screen is not clear.");

}


void test_check_file(void)
{
   polish_stack s;
   interp *p;
   turtle xy_coords;


   p = (interp *) malloc(sizeof(interp));

   if(p == NULL){
      ERROR("Malloc failure.");
   }

   check_file(p, &s, "testing_files/test_file1.txt", &xy_coords);

   sput_fail_unless(p->num != 1, "Checking elements of structure.");
   sput_fail_unless(p->current != 1, "Checking elements of structure.");
   sput_fail_unless(p->num != 10, "Checking elements of structure.");
   sput_fail_unless(p->current != 10, "Checking elements of structure.");
   sput_fail_unless(p->num != 0, "Checking elements of structure.");
   sput_fail_unless(p->current == 0, "Checking elements of structure.");


   free(p);
}


void test_check_file_2(void)
{

   polish_stack s;
   interp *p;
   turtle xy_coords;

   p = (interp *) malloc(sizeof(interp));

   if(p == NULL){
      ERROR("Malloc failure.");
   }

   check_file(p, &s, "testing_files/test_file2.txt", &xy_coords);


   sput_fail_unless(p->num != 1, "Checking elements of structure.");
   sput_fail_unless(p->current != 1, "Checking elements of structure.");
   sput_fail_unless(p->num != 10, "Checking elements of structure.");
   sput_fail_unless(p->current != 10, "Checking elements of structure.");
   sput_fail_unless(p->num != 0, "Checking elements of structure.");
   sput_fail_unless(p->current == 0, "Checking elements of structure.");


   free(p);

}

void test_check_start(void)
{

   int i;
   FILE *file1 = NULL;
   FILE *file2 = NULL;
   FILE *file3 = NULL;
   FILE *file4 = NULL;
   FILE *file5 = NULL;
   interp p;
   polish_stack s;
   SDL_Simplewin w;
   turtle xy_coords;

   initialise_stack(&s);

   s.counter = 0;

   p.num = 0;
   p.current = 0;

   for(i = 0; i < MAX_LEN; i++){
      p.prog_line[i][0] = '\0';
   }

   file1 = fopen("testing_files/test_file1.txt", "r");

   while(fscanf(file1, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file1);

   sput_fail_unless(check_and_start(&p, &s, &w, &xy_coords) == 0, "Incorrect opening bracket identified.");


   file2 = fopen("testing_files/test_file2.txt", "r");

   while(fscanf(file2, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file2);

   sput_fail_unless(check_and_start(&p, &s, &w, &xy_coords) == 0, "Missing opening bracket identified.");


   file3 = fopen("testing_files/test_file3.txt", "r");

   while(fscanf(file3, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file3);

   sput_fail_unless(check_and_start(&p, &s, &w, &xy_coords) == 0, "Missing opening bracket identified.");


   file4 = fopen("testing_files/test_file4.txt", "r");

   while(fscanf(file4, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file4);

   sput_fail_unless(check_and_start(&p, &s, &w, &xy_coords) == 0, "Missing opening bracket identified.");


   file5 = fopen("testing_files/test_file5.txt", "r");

   while(fscanf(file5, "%s", p.prog_line[i++]) == 1 && i < MAX_LEN) {
      p.num = p.num + 1;
   }
   fclose(file5);

   sput_fail_unless(check_and_start(&p, &s, &w, &xy_coords) == 0, "Missing opening bracket identified.");

}


void test_same_string(void)
{

   char *str1 = "{";    char *str11 = "}";
   char *str2 = "{";    char *str12 = "}";

   char *str3 = "FROM"; char *str13 = ":=";
   char *str4 = "FROM"; char *str14 = ":=";

   char *str5 = "TO";   char *str15 = ";";
   char *str6 = "TO";   char *str16 = ";";

   char *str7 = "SET";  char *str17 = "FD";
   char *str8 = "SET";  char *str18 = "FD";

   char *str9 = "DO";   char *str19 = "LT";
   char *str10 = "DO";  char *str20 = "LT";


   sput_fail_unless(string_same(str1, str2) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str3, str4) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str5, str6) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str7, str8) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str9, str10) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str11, str12) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str13, str14) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str15, str16) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str17, str18) == 1, "Same string correctly identified.");
   sput_fail_unless(string_same(str19, str20) == 1, "Same string correctly identified.");

   sput_fail_unless(string_same(str1, str11) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str2, str12) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str3, str13) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str4, str14) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str5, str15) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str6, str16) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str7, str17) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str8, str18) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str9, str19) == 0, "Different string correctly identified.");
   sput_fail_unless(string_same(str10, str20) == 0, "Different string correctly identified.");

}
/*

void test_instrctlist(void)
{

   interp prog_location;
   polish_stack s;

   test_instrctlist_check(&prog_location, &s);

}


void test_instrctlist_check(interp *prog_location, polish_stack *s)
{
   SDL_Simplewin *w;
   turtle *xy_coords;

   srand(time(NULL));

   prog_location = (interp *) malloc(sizeof(interp));

   if(prog_location == NULL){
      ERROR("Malloc failure.");
   }

   process_instruct_list(prog_location, s, &w, &xy_coords);

   prog_location->current = 0;

   sput_fail_unless(prog_location -> prog_line[prog_location -> current] == 0, "Checking elements of structure.");


   prog_location->current = rand() % MAX_LEN;

   strcpy(prog_location->prog_line[prog_location->current], "}");

   process_instruct_list(prog_location, s, &w, &xy_coords);

   sput_fail_unless(prog_location -> prog_line[prog_location -> current] != 0, "Checking elements of structure.");
   sput_fail_unless(prog_location -> prog_line[prog_location -> current+1] != 0, "Checking elements of structure.");

   free(prog_location);

} */



void test_instruction(void)
{

   interp *prog_location;

   polish_stack s;

   SDL_Simplewin w;

   turtle xy_coords;

   prog_location =  (interp *) malloc(sizeof(interp));

   if(prog_location == NULL){
      ERROR("Malloc failure.");
   }

   /* First test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "F 30 }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Second test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "L 4 }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed LT which is valid so should return 1.");

   /* Third test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "T 4 }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed RT which is valid so should return 1.");

   /* Fourth test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "O A FROM 1 TO 5 { FD 5 } }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Fifth test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "FROM }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Sixth test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], " }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Seventh test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "0 }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Eighth test  */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "z }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Ninth test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "m 60 }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   /* Tenth test */

   check_and_start(prog_location, &s, &w, &xy_coords);

   strcpy(prog_location->prog_line[prog_location->current], "s }");

   sput_fail_unless(process_instruction(prog_location, &s, &w, &xy_coords)== 0, "Passed FD which is valid so should return 1.");

   free(prog_location);
}

/*
   Check that function Forward() only recognises "FD"
   instruction followed by <VARNUM> as correct grammar
*/
void test_fd(void)
{
   interp prog;

   turtle xy_coords;

   xy_coords.angle = 60;
   xy_coords.next_x = 90;
   xy_coords.next_y = 100;


   sput_fail_unless(test_fd_check(&prog, &xy_coords,"FS", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"FT", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog,&xy_coords, "FV", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"BU", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog,&xy_coords, "ST", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"RE", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"DO", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"SET", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"DOT", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_fd_check(&prog, &xy_coords,"PT", "A")==0, "Incorrect input failed.");

}

/*
   Check that function LeftTurn() only recognises "LT"
   instruction followed by <VARNUM> as correct grammar
*/
bool test_fd_check(interp *prog, turtle *xy_coords, char* first, char* second)
{

   double test_n, test_x, test_y;
   SDL_Simplewin w;


   prog->current = 0;

   strcpy(prog->prog_line[prog->current], first);
   strcpy(prog->prog_line[prog->current+1], second);

   if(string_same(prog->prog_line[prog->current], "FD")){
      prog->current += 1;

      test_n = check_FD(prog, &w, xy_coords);
      test_x = xy_coords->next_x - (xy_coords->prev_x + \
                                    test_n*cos(xy_coords->angle));
      test_y = xy_coords->next_y - (xy_coords->prev_y + \
                                    test_n*sin(xy_coords->angle));
      if(test_abs(test_x)==true){
         if(test_abs(test_y)==true){
            return true;
         }
      }
   }
   return false;
}


bool test_abs(double test)
{
   if(fabs(test) < FLT_EPSILON){
      return true;
   }
   return false;

}


void test_lt(void)
{
   interp prog;

   turtle xy_coords;

   xy_coords.angle = 60;


   sput_fail_unless(test_lt_check(&prog, &xy_coords, "LT", "1")==1, "Correct input passed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "FS", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "FT", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "FV", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "BU", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "ST", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "RE", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "DO", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "SET", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "DOT", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_lt_check(&prog, &xy_coords, "PT", "A")==0, "Incorrect input failed.");

}


bool test_lt_check(interp *prog, turtle *xy_coords, char* first, char* second)
{

   double test_n, test_diff, test_angle;

   prog->current = 0;

   strcpy(prog->prog_line[prog->current], first);
   strcpy(prog->prog_line[prog->current+1], second);

   test_angle = xy_coords->angle;

   if(string_same(prog->prog_line[prog->current], "LT")){
      prog->current += 1;
      test_n = check_LT_RT(prog, xy_coords);
      test_diff = xy_coords->angle - (test_angle-test_n*PI/TURN_DEGREES);
      if(test_abs(test_diff)==true){
         return true;
      }
   }
   return false;

}

void test_rt(void)
{
   interp prog;

   turtle xy_coords;

   xy_coords.angle = 90;


   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RT", "1")==1, "Correct input passed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RS", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RT", "do")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RW", "5")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RU", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RT", "x")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RE", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "RO", "15")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "SET", "A")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "DOT", "35")==0, "Incorrect input failed.");
   sput_fail_unless(test_rt_check(&prog, &xy_coords, "PT", "A")==0, "Incorrect input failed.");

}

bool test_rt_check(interp *prog, turtle *xy_coords, char* first, char* second)
{

   prog->current = 0;


   strcpy(prog->prog_line[prog->current], first);

   strcpy(prog->prog_line[prog->current+1], second);

   if(string_same(prog->prog_line[prog->current], "RT")){
      prog->current += 1;
      return check_LT_RT(prog, xy_coords);

      return true;
   }
   return false;

}


void test_do_loop(void)
{

   interp prog;
   polish_stack s;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");
   sput_fail_unless(test->test_count != 1, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "DOOO";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "1";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "50";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Second test */

   test->test_arr[0] = "FROM";
   test->test_arr[1] = "A";
   test->test_arr[2] = "DO";
   test->test_arr[3] = "B";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "A";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Third test */

   test->test_arr[0] = ")";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "A";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "B";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Fourth test */

   test->test_arr[0] = "} DO";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "A";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "B";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   /* Fifth test */

   test->test_arr[0] = " ";
   test->test_arr[1] = "A";
   test->test_arr[2] = "FROM";
   test->test_arr[3] = "1";
   test->test_arr[4] = "TO";
   test->test_arr[5] = "8";
   test->test_arr[6] = "{";

   test->test_count = 7;

   sput_fail_unless(test_do_check(&prog, &s, test) == 0, "Correctly identified incorrect instructions.");

   free(test);

}


bool test_do_check(interp *prog, polish_stack *s, test_array *test)
{

   int i=0;

   SDL_Simplewin w;

   turtle xy_coords;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(string_same(prog->prog_line[prog->current], "DO")){
      prog->current += 1;
      check_DO(prog, s, &w, &xy_coords);
      return true;
   }
   else{
      return false;
   }

   free(test);

}

/*
   Check that function Set() parses the
   instructions stored in e.array as correct
   grammar.
*/
void test_set(void)
{

   interp prog;
   polish_stack s;
   test_array *test;
   turtle xy_coords;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "K";
   test->test_arr[1] = "K";
   test->test_arr[2] = ":=";
   test->test_arr[3] = "34";
   test->test_arr[4] = "5";
   test->test_arr[5] = "-";
   test->test_arr[4] = "+";

   test->test_count = 7;

   sput_fail_unless(test_set_check(&prog, &s, &xy_coords, test) == 0, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = "S";
   test->test_arr[1] = "K";
   test->test_arr[2] = ":=";
   test->test_arr[3] = "34";
   test->test_arr[4] = "5";
   test->test_arr[5] = "-";
   test->test_arr[4] = "+";

   test->test_count = 7;

   sput_fail_unless(test_set_check(&prog, &s, &xy_coords, test) == 0, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = "R";
   test->test_arr[1] = "K";
   test->test_arr[2] = ":=";
   test->test_arr[3] = "34";
   test->test_arr[4] = "5";
   test->test_arr[5] = "-";
   test->test_arr[4] = "/";

   test->test_count = 7;

   sput_fail_unless(test_set_check(&prog, &s, &xy_coords, test) == 0, "Correctly parsed instructions.");


}


bool test_set_check(interp *prog, polish_stack *s, turtle *xy_coords, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(string_same(prog->prog_line[prog->current], "SET")){
      prog->current += 1;
      check_SET(prog, s, xy_coords);
      return true;
   }
   else{
      return false;
   }

}

/*
   Check that function VarNum() can distinguish
   between a string containing a number and a string
   containing an uppercase letter.
*/
void test_varnum(void)
{

   interp prog;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "5";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = "10";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = "4.9";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fourth test */

   test->test_arr[0] = "3.6";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fifth test */

   test->test_arr[0] = "20";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Sixth test */

   test->test_arr[0] = "Y";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Seventh test */

   test->test_arr[0] = "Z";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Eighth test */

   test->test_arr[0] = "P";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Ninth test */

   test->test_arr[0] = "DO";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Tenth test */

   test->test_arr[0] = "SET";

   test->test_count = 1;

   sput_fail_unless(test_varnum_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   free(test);

}

bool test_varnum_check(interp *prog, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   if(check_varnum(prog)){
      return true;
   }
   return false;

}

void test_var(void)
{

   interp prog;
   test_array *test;


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");


   /* First test */

   test->test_arr[0] = "A";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Second test */

   test->test_arr[0] = "S";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Third test */

   test->test_arr[0] = "K";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fourth test */

   test->test_arr[0] = "P";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Fifth test */

   test->test_arr[0] = "E";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 1, "Correctly parsed instructions.");

   /* Sixth test */

   test->test_arr[0] = "a";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Seventh test */

   test->test_arr[0] = "6";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Eighth test */

   test->test_arr[0] = "f";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Ninth test */

   test->test_arr[0] = "2.3";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   /* Tenth test */

   test->test_arr[0] = "5.5";

   test->test_count = 1;

   sput_fail_unless(test_var_check(&prog, test) == 0, "Correctly identified invalid instructions.");

   free(test);

}

/*
   Check that function Var() converts a string
   containing an uppercase letter into a character
*/
bool test_var_check(interp *prog, test_array *test)
{

   int i = 0;

   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }
   if(check_var(prog)){
      return true;
   }
   return false;

}


void test_polish(void)
{
/*
   interp prog;
   polish_stack s; */
   test_array *test;
/*
   turtle xy_coords;*/


   test = (test_array *) malloc(sizeof(test_array));

   if(test == NULL){
      ERROR("Malloc failure.");
   }

   test->test_count = 0;

   sput_fail_unless(test->test_count == 0, "Checking elements of structure.");

}

   /* First test */
/*
   test->test_arr[0] = "7";
   test->test_arr[1] = "/";
   test->test_arr[2] = "12";
   test->test_arr[3] = ";";

   test->test_count = 4;

   sput_fail_unless(test_polish_check(&prog, &s, &xy_coords, test) == 0, "Correctly parsed instructions.");


}


bool test_polish_check(interp *prog, polish_stack *s,  turtle *xy_coords, test_array *test)
{
   double test_num=0;
   int i = 0;


   prog->current = 0;

   for(i = 0; i < test->test_count; i++){
      strcpy(prog->prog_line[prog->current+i], test->test_arr[i]);
   }

   test_num = check_polish(prog, s, xy_coords);

   if(test_abs(test_num)==true){
      return true;
   }
   return false;

}*/


void test_op(void)
{

   interp prog;


   sput_fail_unless(test_op_check(&prog, "+") == 1, "Correctly parsed instructions using '+'.");
   sput_fail_unless(test_op_check(&prog, "-") == 1, "Correctly parsed instructions using '-'.");
   sput_fail_unless(test_op_check(&prog, "*") == 1, "Correctly parsed instructions using '*'.");
   sput_fail_unless(test_op_check(&prog, "/") == 1, "Correctly parsed instructions using '/'.");

   sput_fail_unless(test_op_check(&prog, "3") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "10") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "2.5") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "3.3") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "a") == 0, "Correctly identified invalid instructions.");
   sput_fail_unless(test_op_check(&prog, "}") == 0, "Correctly identified invalid instructions.");

}


bool test_op_check(interp *prog, char *test)
{

   prog->current = 0;

   strcpy(prog->prog_line[prog->current], test);

   if(check_op(prog)){
      return true;
   }
   else{
      return false;
   }

}

/*
   Check that the stack pointer is not NULL
*/
void test_init_stack(void)
{

   polish_stack stack, *s;

   s = &stack;

   initialise_stack(s);

   sput_fail_unless(s->tp != 0, "Stack initialisation complete.");
   assert(s != NULL);

   assert(s->tp != NULL);
   sput_fail_unless(s->tp != 0, "Stack initialisation complete.");

   sput_fail_unless(s->counter == 0, "Stack initialisation complete.");

   sput_fail_unless(initialise_stack(s) == 1, "Correctly initialised stack.");

   sput_fail_unless(s->counter == 0, "Correctly initialised stack.");
   sput_fail_unless(s->tp != 0, "Correctly initialised stack.");
   sput_fail_unless(s->tp->prev == 0, "Correctly initialised stack.");

}

/*
   Check that function Push() will push a string containing
   a character or number (first digit only) onto the stack.

   Check that function Pop() will pop the last element
   (only the first digit for numbers) off the stack.
*/
void test_push_stack(void)
{

   polish_stack stack, *s;

   s = &stack;

   initialise_stack(s);

   push_on_stack(s, "5");

   assert(s != NULL);
   assert(s->tp != NULL);

   assert(pop_off_stack(s)== '5');
   sput_fail_unless(pop_off_stack(s)== 0, "Stack initialisation complete.");
   sput_fail_unless(s->tp == 0, "5 is at the top of the stack.");
/*
   push_on_stack(s, "1");

   assert(s != NULL);
   assert(s->tp != NULL);

   assert(pop_off_stack(s)== '1');
   sput_fail_unless(pop_off_stack(s)== 0, "Stack initialisation complete.");
   sput_fail_unless(s->tp == 0, "1 is at the top of the stack.");

   push_on_stack(s, "30");

   assert(s != NULL);
   assert(s->tp != NULL);

   assert(pop_off_stack(s)== '3');
   sput_fail_unless(pop_off_stack(s) == 0, "Stack initialisation complete.");
   sput_fail_unless(s->tp == 0, "3 is at the top of the stack."); */

   free_stack(s);

}


void test_free_stack(void)
{

   polish_stack stack, *s;

   s = &stack;

   initialise_stack(s);

   free_stack(s);

   sput_fail_unless(s->tp == 0, "Stack freed.");

}
